% Predicts the stability of travelling waves based on the nearest neighbour
% approach introduced elsewhere
% Works only for a given type of travelling wave. Currently this is for
% waves of the type (0,1)-(1,1)-(1,0) on a (0,0) backgroud, such as
% generated by the topology M_int = [0 1; -1 1]
clear all
close all
clc
set(0, 'defaulttextinterpreter', 'latex')
%% Parameters
% lattice parameters
gz = 16;
N = gz^2;
a0 = 1.5;
rcell = 0.2;
Rcell = rcell*a0;
lambda12 = 1.2;
lambda = [1 lambda12];

% circuit parameters
M_int = [0 1; -1 1];
Con = [18 16];
Coff = [1 1];
K = [0 9; 11 4];
hill = Inf;
noise = 0;

% K for all cells
K_all = zeros(N, 2, 2);
for i=1:N
    K_all(i, :, :) = K;
end

% initial conditions
p0 = [0.5 0.5];
iniON = round(p0*N);
%iniON = 1

% Initialize parameters
%[pos,ex,ey] = init_cellpos_hex(gridsize,gridsize);
%dist = dist_mat(pos,gridsize,gridsize,ex,ey);
mcsteps = 0;
[pos, dist, ~, ~] = initial_cells_random_markov_periodic(gz, mcsteps, rcell);

dist_vec = a0*dist(1,:);
r = dist_vec(dist_vec>0); % exclude self influence
fN = sum(sinh(Rcell)*sum(exp(Rcell-r)./r)); % calculate signaling strength

%% K profile
% Choose which interaction to make spatially dependent
% interaction = [i j] means the j->i interaction
int_wave = [2 1];

% Parameters
Lx = 1; %default size

Ax = 0.6;
nx = 1; %number of times the wave fits into x-range
lambda_x = 1/nx*Lx;
Ay = 0.0;
ny = 1;
lambda_y = 1/ny*sqrt(3)/2*Lx;
wave_x = Ax.*square(pos(:, 1).*(2*pi/lambda_x));
wave_y = Ay.*square(pos(:, 2).*(2*pi/lambda_y));

% sinusoidal wave
% K_func = @(x, y) K.*(1 + Ax.*sin(2.*pi.*x/lambda_x) + Ay.*sin(2.*pi.*y/lambda_y));
% K_all = K_func(pos(:, 1), pos(:, 2));

% square wave
K_all(:, int_wave(1), int_wave(2)) = K(int_wave(1),int_wave(2)).*(1 + wave_x + wave_y);

%{
figure;
x = 0:0.01:1;
y = 0:0.01:1;
plot(pos(:, 1), K_all, 'bo');
%}

%{
figure;
imagesc(reshape(K_cells_all, gz, gz))
colorbar;
set(gca, 'YDir', 'normal');
%}
%% Check that K values should still be able to generate waves (nearest-neighbour calculation)
Kmin = min(K_all(:, int_wave(1), int_wave(2)));
Kmax = max(K_all(:, int_wave(1), int_wave(2)));

Kmin_set = K; 
Kmin_set(int_wave(1), int_wave(2)) = Kmin;
Kmax_set = K; 
Kmax_set(int_wave(1), int_wave(2)) = Kmax;

conditions_met = zeros(2, 3);
wave_types = {'plane', 'inward', 'outward'};
for i=1:numel(wave_types)
    wave_type = wave_types{i};
    conditions_met(1, i) = all(trav_wave_conditions_nn(dist, Con, Kmin_set,...
        rcell, a0, lambda, wave_type));
    conditions_met(2, i) = all(trav_wave_conditions_nn(dist, Con, Kmax_set,...
        rcell, a0, lambda, wave_type));
end

disp('Nearest neighbour conditions for plane waves met?');
disp('Rows: [Kmin; K_max], Columns = [plane, inward, outward]');
disp(conditions_met);
